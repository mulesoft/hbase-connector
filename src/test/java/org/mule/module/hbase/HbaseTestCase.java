/**
 * Copyright (c) MuleSoft, Inc. All rights reserved. http://www.mulesoft.com
 *
 * The software in this package is published under the terms of the CPAL v1.0
 * license, a copy of which has been included with this distribution in the
 * LICENSE.md file.
 */

/**
 * This file was automatically generated by the Mule Cloud Connector Development Kit
 */

package org.mule.module.hbase;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyLong;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.reset;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import org.mule.module.hbase.api.BloomFilterType;
import org.mule.module.hbase.api.CompressionType;
import org.mule.module.hbase.api.HBaseService;

import java.util.Map;

import org.apache.hadoop.hbase.client.Result;
import org.apache.hadoop.hbase.client.RowLock;
import org.junit.Before;
import org.junit.Test;

public class HbaseTestCase
{
    private static final String SOME_ROW_KEY = "some-row-key";
    private static final String TABLE_NAME = "table-name";
    private static final String COLUMN_NAME = "column-name";
    private static final String COLUMN_QUALIFIER = "column-qualifier";
    
    private HbaseCloudConnector connector;
    private HBaseService facade;
    private RowLock lock;

    @Before
    public void before()
    {
        connector = new HbaseCloudConnector();
        facade = mock(HBaseService.class);
        connector.setFacade(facade);
        lock = mock(RowLock.class);
    }

    @Test
    public void testAlive()
    {
        when(facade.alive()).thenReturn(false);
        assertFalse(connector.isAliveServer());
        verify(facade).alive();

        reset(facade);
        when(facade.alive()).thenReturn(true);
        assertTrue(connector.isAliveServer());
        verify(facade).alive();
    }

    @Test
    public void testTableAdmin()
    {
        assertFalse(connector.existsTable(TABLE_NAME));
        verify(facade).existsTable(eq(TABLE_NAME));

        connector.createTable(TABLE_NAME);
        verify(facade).createTable(eq(TABLE_NAME));

        connector.deleteTable(TABLE_NAME);
        verify(facade).deleteTable(eq(TABLE_NAME));

        connector.isEnabledTable(TABLE_NAME);
        verify(facade).isDisabledTable(eq(TABLE_NAME));

        connector.enableTable(TABLE_NAME);
        verify(facade).enableTable(eq(TABLE_NAME));

        connector.disableTable(TABLE_NAME);
        verify(facade).disabeTable(eq(TABLE_NAME));

        connector.addColumnFamily(TABLE_NAME, COLUMN_NAME, 3, true, 7);
        verify(facade).addColumn(eq(TABLE_NAME), eq(COLUMN_NAME), eq(3), eq(true), eq(7));

        connector.existsColumnFamily(TABLE_NAME, COLUMN_NAME);
        verify(facade).existsColumn(eq(TABLE_NAME), eq(COLUMN_NAME));

        Map<String, String> map = mock(Map.class);
        connector.modifyColumnFamily(TABLE_NAME, COLUMN_NAME, 5, 123,  CompressionType.LZO, CompressionType.LZO, false, 0, true, BloomFilterType.NONE, 12, map);
        verify(facade).modifyColumn(eq(TABLE_NAME), eq(COLUMN_NAME), eq(5), eq(123), eq(CompressionType.LZO), eq(CompressionType.LZO),
            eq(false), eq(0), eq(true), eq(BloomFilterType.NONE), eq(12), eq(map));

        connector.deleteColumnFamily(TABLE_NAME, COLUMN_NAME);
        verify(facade).deleteColumn(eq(TABLE_NAME), eq(COLUMN_NAME));

        connector.deleteValues(TABLE_NAME, SOME_ROW_KEY, "family", "qualifier", 123L, false, lock);
        verify(facade).delete(eq(TABLE_NAME), eq(SOME_ROW_KEY), eq("family"), eq("qualifier"), eq(123L),
            eq(false), eq(lock));

        connector.scanTable(TABLE_NAME, "family", "qualifier", 123L, 456L, 2, true, 2, "row20", "row30", 50);
        verify(facade).scan(eq(TABLE_NAME), eq("family"), eq("qualifier"), eq(123L), eq(456L), eq(2), eq(true),
            eq(2), eq("row20"), eq("row30"), eq(50));

        connector.incrementValue(TABLE_NAME, SOME_ROW_KEY, "f1", "q", 3L, true);
        verify(facade).increment(eq(TABLE_NAME), eq(SOME_ROW_KEY), eq("f1"), eq("q"), eq(3L), eq(true));

        assertFalse(connector.checkAndPutValue(TABLE_NAME, SOME_ROW_KEY, "f1", "q1", "v1", "f2", "q2", 123L, "v2",
            true, lock));
        verify(facade).checkAndPut(eq(TABLE_NAME), eq(SOME_ROW_KEY), eq("f1"), eq("q1"), eq("v1"), eq("f2"),
            eq("q2"), eq(123L), eq("v2"), eq(true), eq(lock));

        assertFalse(connector.checkAndDeleteValue(TABLE_NAME, SOME_ROW_KEY, "f1", "q1", "v1", "f2", "q2", 123L,
            false, lock));
        verify(facade).checkAndDelete(eq(TABLE_NAME), eq(SOME_ROW_KEY), eq("f1"), eq("q1"), eq("v1"),
            eq("f2"), eq("q2"), eq(123L), eq(false), eq(lock));
    }

    @Test
    public void testGetByRow()
    {
        Result mockResult = mock(Result.class);
        when(mockResult.isEmpty()).thenReturn(false);
        when(facade.get(eq(TABLE_NAME), eq(SOME_ROW_KEY), eq(COLUMN_QUALIFIER), eq(COLUMN_NAME), anyInt(), anyLong())).thenReturn(mockResult);

        Result result = connector.getValues(TABLE_NAME, SOME_ROW_KEY, COLUMN_QUALIFIER, COLUMN_NAME, 3, 12345L);
        assertFalse(result.isEmpty());

        connector.putValue(TABLE_NAME, SOME_ROW_KEY, COLUMN_NAME, "q", 123L, "value", true, lock);
        verify(facade).put(eq(TABLE_NAME), eq(SOME_ROW_KEY), eq(COLUMN_NAME), eq("q"), eq(123L), eq("value"),
            eq(true), eq(lock));
    }
}
